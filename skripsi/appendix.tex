\appendix
% \userpackeage{listings}
\titleformat{\chapter}[display] {\normalfont\huge\bfseries\centering} {Lampiran \thechapter}{12pt}{\LARGE}
\clearpage
\renewcommand\bibname{LAMPIRAN}\addcontentsline{toc}{chapter}{LAMPIRAN}
\chapter{sumber kode}
\section{Kode Program gambarBoids.js}
\begin{lstlisting}
function draw(){
	var c = arguments[0];
	var ctx = c.getContext("2d");
	let x=arguments[1];
	let y=arguments[2];
	let vx=arguments[3];
	let vy=arguments[4];
	let radius=arguments[5];
	let sudut1=arguments[6];
	let sudut2=arguments[7];
	let colored =arguments[8];
	let r=5; //3
	let theta=1*Math.atan2(vy,vx) + Math.PI / 2;
	ctx.save();
	ctx.beginPath();
	ctx.translate(x,y);
	ctx.rotate(theta);
	//ctx.fillStyle="rgba(255,000,000,1)"; //this.color
	ctx.fillStyle= colored;
	//ctx.arc(0,0,radius,-sudut1,-sudut2,true);
	//ctx.arc(0,0,radius,1.2*Math.PI,1.8*Math.PI);
	ctx.moveTo(0,-r*2);
	ctx.lineTo(r,r*2);
	ctx.lineTo(-r,r*2);
	ctx.lineTo(0,-r*2);
	ctx.fill();
	ctx.closePath();
	ctx.restore();
	//draw(caOut,X,Y,f[i].vx,f[i].vy,radiusA,sudut1,sudut2);
}
function clear(){
	var ca = arguments[0];
	var ctx = ca.getContext("2d");
	ctx.beginPath();
	ctx.clearRect(0,0,caOut.width,caOut.height);
	ctx.closePath();
}
\end{lstlisting}
\section{Kode Program sides2.js}
\begin{lstlisting}
class Sides2 {
	//create constructor
	constructor() {
		if(arguments.length == 0){
			this.p = [
			new Vect3(),
			new Vect3()
			];
		} else if(arguments.length == 2) {
			this.p = [
			arguments[0],
			arguments[1]
			];
		} else if(arguments.length == 1){
			if(arguments[0] instanceof Sides2)
			this.p = [
				arguments[0].p[0],
				arguments[0].p[1]
			];
		}
	}
	// Get string value
	strval() {
		var s = "(";
		s += this.p[0].strval() + ", ";
		s += this.p[1].strval() + ", ";
		// s += this.p[2].strval() + ", ";
		// s += this.p[3].strval() + ", ";
		s += ")";
		return s;
	}
	
	// Get center coordinate
	center() {
		var N = this.p.length;
		var p0 = new Vect3();
		for(var i in this.p) {
			p0 = Vect3.add(p0, this.p[i]);
		}
		p0 = Vect3.div(p0, N);
		return p0;
	}
}
\end{lstlisting}
\section{vect3.js}
\begin{lstlisting}
/*
	vect3.js
	Vector in 3-d Cartesian coordinate system
	
	Sparisoma Viridi | dudung@gmail.com
	
	20171226
	Create this object (again).
	20171227
	Add some comments for clearer documentation.
*/

// Define class of Vect3
class Vect3 {
	// Create three different types of constructor
	constructor() {
		if(arguments.length == 0) {
			this.x = 0.0;
			this.y = 0.0;
			this.z = 0.0;
		} else if(arguments.length == 3) {
			this.x = arguments[0];
			this.y = arguments[1];
			this.z = arguments[2];
		} else if(arguments.length == 1) {
			if(arguments[0] instanceof Vect3)
			this.x = arguments[0].x;
			this.y = arguments[0].y;
			this.z = arguments[0].z;
		}
	}
	
	// Get string value
	strval() {
		var s = "(";
		s += this.x + ", ";
		s += this.y + ", ";
		s += this.z;
		s += ")";
		return s;
	}
	
	// Add some Vect3
	static add() {
		var N = arguments.length;
		var x = 0.0;
		var y = 0.0;
		var z = 0.0;
		for(var i = 0; i < N; i++) {
			x += arguments[i].x;
			y += arguments[i].y;
			z += arguments[i].z;
		}
		var p = new Vect3(x, y, z);
		return p;
	}
	
	// Substract two Vect3
	static sub() {
		var x = arguments[0].x - arguments[1].x;
		var y = arguments[0].y - arguments[1].y;
		var z = arguments[0].z - arguments[1].z;
		var p = new Vect3(x, y, z);
		return p;
	}
	
	// Multiply Vect3 with scalar or vice versa
	static mul() {
		var a = arguments[0];
		var b = arguments[1];
		var x, y, z;
		if(a instanceof Vect3) {
			x = a.x * b;
			y = a.y * b;
			z = a.z * b;
		} else if(b instanceof Vect3) {
			x = a * b.x;
			y = a * b.y;
			z = a * b.z;
		}
		var p = new Vect3(x, y, z);
		return p;
	}
	
	// Divide Vect3 with scalar
	static div() {
		var a = arguments[0];
		var b = arguments[1];
		var	x = a.x / b;
		var	y = a.y / b;
		var	z = a.z / b;
		var p = new Vect3(x, y, z);
		return p;
	}
	
	// Dot two Vect3
	static dot() {
		var a = arguments[0];
		var b = arguments[1];
		var	xx = a.x * b.x;
		var	yy = a.y * b.y;
		var	zz = a.z * b.z;
		var d = xx + yy + zz;
		return d;
	}
	
	// Cross two Vect3
	static cross() {
		var a = arguments[0];
		var b = arguments[1];
		var	x = a.y * b.z - a.z * b.y;
		var	y = a.z * b.x - a.x * b.z;
		var	z = a.x * b.y - a.y * b.x;
		var p = new Vect3(x, y, z)
		return p;
	}
	
	// Get length of a Vect3
	len() {
		var l = Math.sqrt(Vect3.dot(this, this));
		return l;
	}
	
	// Get unit vector of a Vect3
	unit() {
		var l = this.len();
		var p = Vect3.div(this, l);
		return p;
	}

	// create for 2d cross
	static cross(){
		var a = arguments[1];
		var b = arguments[2];
		var x = (a.x*b.y) - (a.y*b.x);
		var p = new Vect3() 
	}

}

\end{lstlisting}
\section{Kode Program index.html}
\begin{lstlisting}
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>BOIDS!</title>
	<link rel="stylesheet" href="css/style.css">
	<!--[if IE]>
		<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>

<body id="home">

  <div id="boids-wrapper">
    <canvas id="boids"></canvas>
		<div id="boids-controls-container">
			<div id="mobile-boids-controls">
				<button id="introversion-mobile">Introversion</button>
				<button id="speed-mobile">Speed</button>
				<button id="walls-mobile" class="boids-checkbox-on">Walls</button>
				<button id="collisions-mobile">Collisions</button>
				<button id="mouse-seek-mobile">Seek Mouse</button>
				<button id="racism-mobile">Racism</button>
				<button id="diversity-mobile">Diversity</button>
			</div>
			<div id="introversion-control-container" class="boids-control boids-control-range">
				<span class="boids-control-close"></span>
				<div class="range-slider">
					<label for="introversion"><p>Introversion</p></label>
					<input class="input-range" type="range" step="1" value="5" min="0" max="10" name="introversion" id="introversion">
			    <span class="range-value"></span>
				</div
>			</div>
			<div id="speed-control-container" class="boids-control boids-control-range">
				<span class="boids-control-close"></span>
				<div class="range-slider">
					<label for="introversion"><p>Speed</p></label>
					<input class="input-range" type="range" step="1" value="5" min="0" max="10" name="speed" id="speed">
			    <span class="range-value"></span>
				</div>
			</div>
			<div class="boids-control boids-control-checkbox">
				<div class="checkbox">
					<p>Walls</p>
					<input type="checkbox" id="walls" name="walls"/>
					<label for="walls"></label>
				</div>
			</div>
			<div class="boids-control boids-control-checkbox">
				<div class="checkbox">
					<p>Collisions</p>
					<input type="checkbox" id="collision-detection" name="collision-detection"/>
					<label for="collision-detection"></label>
				</div>
			</div>
			<div class="boids-control boids-control-checkbox">
				<div class="checkbox">
					<p>Seek Mouse</p>
					<input type="checkbox" id="mouse-seek" name="mouse-seek"/>
					<label for="mouse-seek"></label>
				</div>
			</div>
			<div id="racism-control-container" class="boids-control boids-control-range">
				<span class="boids-control-close"></span>
				<div class="range-slider">
					<label for="introversion"><p>Racism</p></label>
					<input class="input-range" type="range" step="1" value="0" min="0" max="10" name="racism" id="racism">
			    <span class="range-value"></span>
				</div>
			</div>
			<div id="diversity-control-container" class="boids-control boids-control-range">
				<span class="boids-control-close"></span>
				<div class="range-slider">
					<label for="introversion"><p>Diversity</p></label>
					<input class="input-range" type="range" step="1" value="8" min="1" max="8" name="diversity" id="diversity">
			    <span class="range-value"></span>
				</div>
			</div>
			<div id="fps">
				<p><span id="fps-number"></span> fps</p>
			</div>

			<div class="startup-control">
				
					<p>Startup-Control</p>
					<button id="Start" onlick="startSimu()">Start</button>
					<button id="Stop" onlick="stopSimu()">Stop </button>
					<button>Start Again</button>
					<button>Restart</button>
				</div>
			</div>
			<div id="varian-">
			<p>Varian Controls</p>
		</div>



	</div>
	<p >Varian Controls</p>
  <script src="js/sides2.js"></script>
  <script src="js/vect3.js"></script>
  <script src="js/victor.min.js"></script>
  <script src="js/script.js"></script>
  <script src="js/boid.js"></script>
  <script src="js/gambarBoids.js"></script>
  
</body>
</html>

\end{lstlisting}
\section{Kode Program boids.js}
\begin{lstlisting}
class Boid {

 //constructor boids
  constructor(boid) {

    // Initial Properties
    this.id = boid.id;

    this.position = new Victor( boid.x, boid.y );
    this.positionI = new Victor();

    // for loop
    this.k1 = new Victor();
    this.k2 = new Victor();
    this.k3 = new Victor();
    this.k4 = new Victor();
    this.bun = new Victor();
    this.h = new Victor(1,1);
    this.half = new Victor(0.5,0.5);
    this.two = new Victor(2,2);
    this.Six = new Victor(6,6);
    //

    this.positionTheta = Math.atan2();
    this.distanceFromCenter0 = this.position.distance(center);
    this.coordinateO = new Victor (0,0);
    this.x ;
    this.y ;

    this.radius = boid.radius * radiusCoefficients[ boid.radiusCoefficient ];
    this.introversionCoefficient = boid.introversionCoefficient;
    this.introversion = boid.introversion * this.introversionCoefficient;
    this.quicknessCoefficient = boid.quicknessCoefficient;
    this.quickness = boid.quickness * this.quicknessCoefficient;
    this.racismCoefficient = boid.racismCoefficient;
    this.racism = boid.racism * boid.racismCoefficient;
    this.color = boid.color;
    this.volume = (4/3) * Math.PI * Math.pow( this.radius,3 );

;
    this.angle;
    this.angle2 = 3/2*Math.PI;    


    this.distanceFromCenter = this.position.clone().distance(center);
    this.distanceFromCenter = this.position.distance(center);

    this.positionC = new Victor( this.distanceFromCenter*Math.cos(this.angularVelocity),this.distanceFromCenter*Math.sin(this.angularVelocity));
    this.theta = 0; 
    this.frequency = 0 ;
    this.radians =  Math.PI*2;//*Math.random();

    // Speed & Velocity & Force
    this.maxSpeed = speedIndex * this.quickness;
    this.speed = this.maxSpeed * .5;
    this.speedangular = this.speed/this.distanceFromCenter;

    this.angularVelocity = this.speed/this.distanceFromCenter;
 
    var radians = Math.PI; //* getRandomInt(-99,100) / 100;
 
    this.velocity = new Victor( this.speed * Math.cos( radians ), this.speed * Math.sin( radians ) )
    this.velocity0 = new Victor(Math.cos(this.radians)*this.distanceFromCenter,Math.sin(this.radians)*this.distanceFromCenter);
  //Force and Accel
    this.maxForce = 0.25//.5;
    this.maxForce2 = .1;
    this.acceleration = new Victor(0,0);
    this.angularAcceleration;
    this.desiredPosition;
    this.target;
  }
////////////// meta transform
    transform() {
    var realPosition = transform({x:this.position.x ,y:this.position.y});

  }
////////////////

  seek( target ){
    var targetposition = target.clone();
    var diff = targetposition.subtract(this.position);
    var desired = new Victor(diff.x,diff.y);
    this.desiredPosition = desired;
    this.target = diff;

    //area buffer seek biar seaknya beda
    if (target.radius) {
      var buffer = target.radius + this.radius + 1;
    } else {
      var buffer = this.radius * 2 + 1;
    }
    //
    var dist = diff.magnitude();
    if (dist < buffer) {
      desired.x = 0;
      desired.y = 0;
    } else if ( dist <= 100 ) {
      //normalize and multiply
      desired.normalize();
      desired.divide({x:this.maxSpeed * dist / 100,y:this.maxSpeed * dist / 100});
    } else {
      desired.limitMagnitude(this.maxSpeed);
    }
    desired.subtract(this.velocity);
    desired.limitMagnitude(this.maxForce);
    return desired;
  }

  //this must edited to seek center canvas target position
   centripetal( boids ){
    var sum = new Victor();
    var steer = new Victor();
    var u = new Victor(100,100);
    var t = 0,dt=1;
    for (var i = 0; i < boids.length; i++) {
      var desiredtoCenter = Math.pow(this.velocity,2)/distanceFromCenter;
      var nowPosition = this.position.clone();
      var vecKaaba = Victor.fromObject(wallsKaaba);
      var distanceFromCenter =this.position.clone().distance(center); //hajar aswad

      var centerKaaba = new Victor(surf.center().x,surf.center().y);
      var distanceFromCenter2 = this.position.clone().distance(centerKaaba);
      var pathCircular = 2*Math.PI* distanceFromCenter;
      var theta = 1;

   
        var N = sides.length;
        
        if ( (distanceFromCenter2 > 0 &&distanceFromCenter2 < 50) ) {//distanceFromCenter2 > 0 &&distanceFromCenter2 < 50

      
        var thisposition = this.position.clone();
        var diff = thisposition.subtract(centerKaaba);
        var diffVelocity = diff;
        diff.normalize();
        diff.multiply({x:distanceFromCenter,y:distanceFromCenter});
    
        sum.add(diff);
        t+=dt
        }
        //force to area that make boids circular path 
        if ( (distanceFromCenter2 > 50 && distanceFromCenter2 <= 500 ) ) {

        var thisposition = this.position.clone();
        var diff = thisposition.subtract(centerKaaba);
 
        const diffVelocity = diff;

        diff.normalize();
        diff.multiply({x:distanceFromCenter,y:distanceFromCenter});

        sum.subtract(diff);

        t+=dt
        }else{

        }
        // 
      //}
      
    }
    if (t > 0) {
      sum.divide({x:t,y:t});
      sum.normalize();
      sum.multiply({x:this.maxSpeed,y:this.maxSpeed});
      steer = sum.add(this.velocity);
      steer.limitMagnitude(this.maxForce);
      return steer;
    } else {
      return steer;
    }
  }


    circularMotion( boids ){
    var sum = new Victor();
    var steer = new Victor();
    var t = 0,dt=1;
    for (var i = 0; i < boids.length; i++) {

      var desiredtoCenter = Math.pow(this.velocity,2)/distanceFromCenter;
      var distanceFromCenter =this.position.clone().distance(center);

      var pathCircular = 2*Math.PI* distanceFromCenter;
      var theta = 1;
      
      if ( (distanceFromCenter < 50 && distanceFromCenter < 300 ) ) {
        var thisposition = this.position.clone();
        var thisvelocity = this.velocity.clone();
        var thispositionX = thisposition.x + (distanceFromCenter*Math.sin(toRadian(1)));
        var thispositionY = thisposition.y + (distanceFromCenter*Math.cos(toRadian(1)));
        var diff = thisposition.add(new Victor(thispositionX,thispositionY));
        diff.normalize();

        sum.add(diff);
        t+=dt
      }
    }
    if (t > 0) {
      sum.divide({x:t,y:t});
      sum.normalize()
      sum.multiply({x:this.maxSpeed,y:this.maxSpeed});
      steer = sum.subtract(this.velocity);
      steer.limitMagnitude(this.maxForce);
      return steer;
    } else {
      return steer;
    }
  }


  separate( boids ){
    var sum = new Victor();
    var t = 0,dt=1;
    
    for (var j = 0; j < boids.length; j++) {
      if ( this.color != boids[j].color ) {
        var racismMultiplier = this.racism;
      } else {
        var racismMultiplier = 0;
      }
      var desiredSeparation = this.radius + boids[j].radius + ( 25 * this.introversion ) + ( 50 * racismMultiplier );
      var sep = this.position.clone().distance(boids[j].position);
      if ( (sep > 0) && (sep < desiredSeparation) ) {
        var thisposition = this.position.clone();
        var diff = thisposition.subtract(boids[j].position);
        diff.normalize();
        diff.divide({x:sep,y:sep});
        sum.add(diff);
        t+=dt
      }
    }
    if (t > 0) {
      sum.divide({x:t,y:t});
      sum.normalize();
      sum.multiply({x:this.maxSpeed,y:this.maxSpeed});
      sum.subtract(this.velocity);
      sum.limitMagnitude(this.maxForce);
    }
    return sum;
  }

 
  align( boids ) {
    var neighborDist = 50;//50
    var sum = new Victor();
    var steer = new Victor();
    var t = 0,dt=1;
    for (var i = 0; i < boids.length; i++) {
      var dist = this.position.distance(boids[i].position);
      if ( dist > 0 && dist < neighborDist ) {
        sum.add(boids[i].velocity);
        t+=dt;
      }
    }
    if (t > 0) {
      sum.divide({x:t,y:t});
      sum.normalize()
      sum.multiply({x:this.maxSpeed,y:this.maxSpeed});
      steer = sum.subtract(this.velocity);
      steer.limitMagnitude(this.maxForce);
      return steer;
    } else {
      return steer;
    }
  }


  cohesion( boids ) {
    var neighborDist = 50;//50
    var sum = new Victor();
    var t = 0,dt=1;
    for (var i = 0; i < boids.length; i++) {
      var dist = this.position.distance(boids[i].position);
      if ( dist > 0 && dist < neighborDist ) {
        sum.add(boids[i].position);
        t+=dt;
      }
    }
    if (t > 0) {
      sum.divide({x:t,y:t});
      return this.seek(sum);
    } else {
      return sum;
    }
  }


  avoidWalls() {

    var buffer = mobile ? 5 : 15;

    if ( this.distanceFromHorWall() < this.radius * buffer || this.distanceFromVertWall() < this.radius * buffer ) {
      return this.seek(center);
    } else { return false; }

  }


  flock() {

    // Get Forces

    var alignForce = this.align(boids);
    //console.log(alignForce);

    var circularMotionForce = this.circularMotion(boids);
    if ( mouseSeek ){ 
      var mouseForce = this.seek(center);//mouse.position
      var x = new Victor(0,0 );
      var mouseForce2 = this.seek(x);
    }
    //if ( mouseSeek ) var mouseForce = this.seek(mouse.position);//mouse.position
    var separateForce = this.separate(boids);
    var cohesionForce = this.cohesion(boids);
    ///
    var centripetalForce = this.centripetal(boids);
    ////
    if ( walls ) var avoidWallsForce = this.avoidWalls();


    // Weight Forces
    var centripetalWeight = 1;
    var circularWeight = 1;
    //
    var alignWeight = 1; //1.2
    if ( mouseSeek ) var mouseWeight = 0.5; //.2
    var separateWeight = 1;
    var cohesionWeight = 1;
    if ( walls ) var avoidWallsWeight = 1.2;

    // Apply forces
    
    this.applyForce( alignForce, alignWeight );
    if ( mouseSeek ){ 
      this.applyForce( mouseForce, mouseWeight );
      this.applyForce( mouseForce2, mouseWeight );
    }
    this.applyForce( separateForce, separateWeight );
    this.applyForce( cohesionForce, cohesionWeight );
    //
    //this.applyForce(centrifugalForce, centrifugalWeight );
    this.applyForce(centripetalForce, centripetalWeight );

    //this.applyForce(circularMotionForce, circularWeight );
    //
    var distanceFromCenter =this.position.clone().distance(center);
    
    //
    if ( walls && avoidWallsForce ) this.applyForce( avoidWallsForce, avoidWallsWeight );

  }



  //acceleration
  applyForce( force, coefficient ) {
    if ( ! coefficient ) { var coefficient = 1; }
    force.divide({x:coefficient,y:coefficient});
    this.velocity.add(force);
    this.velocity.limitMagnitude( this.maxSpeed );
  }


    //calculate
  nextPosition() {

    // Update position
    let k1,k2,k3,k4,bun;
    var positiont= this.position.clone(); 
    var velocityt = this.velocity.clone();
    var positiont2= this.position.clone(); 
    var velocityt2 = this.velocity.clone();

    function u(p,v){
      var uv = p.add(v);
      return uv
    }

    const two = new Victor(2,2);
    const h = new Victor(0.5,0.5);
    const p0 = this.position

    var vecP = this.position.toArray();
    var vecV = this.velocity.toArray();
    var fLen=1,jLen=1;
    var upS =[,];
    for (let i = 0; i < vecP.length; i++) {
      for (let j = 0; j < vecV.length; j++){
        upS[i]= vecP[i]+vecV[i];
      }
    }
    




    this.velocity = this.velocity.add(this.acceleration);
    this.positionI = this.position.add(this.velocity);//.multiply(this.h);
    //console.log(this.positionI);
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function rk4(x,v){
      var x1 = x;
      var v1 = v;
      //var h1 = h;
      
      var two = new Victor(2,2);
      var h = new Victor(0.5,0.5);
      var Six = new Victor(6,6);

      function f(x0,v0){
        x0.add(v0);
      }
      console.log("TEST"+f(x1.clone(),v1.clone()));
      var k1 = f(x1.clone(),v1.clone()).multiply(h);
      //console.log("k1:"+k1);

      var k2 = f(x1.clone().add(k1.clone().divide(two)),v1.clone().add(h.clone().divide(two))).multiply(h);
      var k3 = f(x1.clone().add(k2.clone().divide(two)),v1.clone().add(h.clone().divide(two))).multiply(h);
      var k4 = f(x1.clone().add(k3),v1.clone.add(h)).multiply(h);
      
      var bun = k1.clone().add(k2.clone().multiply(two)).add(k3.clone().multiply(two)).add(k4).multiply(h).divide(Six);
      //var bun = k1.clone().add(k2.clone().multiply(two)).add(k3.clone().multiply(two)).add(k4).multiply(h);
      //var vN = x1.clone().add(bun.clone().multiply(h).divide(Six));
      var vN = bun
      console.log("V"+vN);
      return(vN);
    }

    //rk4(this.position,this.velocity);
    //console.log("apakah ini:"+rk4(this.position,this.velocity));
    // this.velocity.add(this.h)
    // this.positionI = this.positionI.add(rk4(this.position,this.velocity));
    // console.log("POS"+this.positionI);
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // k1 = (this.position.add(this.velocity)).multiply(this.h);
    // this.k1.copy(k1);
    // console.log("k1"+this.k1);
    // // k2 = positiont.add(k1.divide(this.two)).add(velocityt2).add(this.h.divide(this.two)).multiply(this.h);
    // console.log("k2"+k2);
    // k3 = positiont.add(k2.divide(this.two)).add(velocityt).add(this.h.divide(this.two)).multiply(this.h);
    // k4 = positiont.add(k3).add(velocityt).add(this.h).multiply(this.h);
    // this.bun = k1.add(k2.multiply(this.two)).add(k3.multiply(this.two)).add(k4).divide(this.Six);
    // this.positionI = this.position.add(this.bun);
    // //console.log(this.positionI)
    // console.log(this.position);
    // console.log(this.velocity);
    // this.k1 = this.position.add(this.velocity).multiply(this.h);
    // this.k2 = this.position.add(this.k1.divide(this.two)).add(this.velocity).add(this.h.divide(this.two)).multiply(this.h);
    // this.k3 = this.position.add(this.k2.divide(this.two)).add(this.velocity).add(this.h.divide(this.two)).multiply(this.h);
    // this.k4 = this.position.add(this.k3).add(this.velocity).add(this.h).multiply(this.h);
    //console.log(this.position);

    ////////////////////////////////////////////////
    // this.k1 = this.k1.add(u(this.position,this.velocity)).multiply(h);
    // console.log("k1"+this.k1);
    // this.k2 = this.k2.add(u(this.position.add(this.k1.clone().divide(two)),this.velocity.add(h.divide(two)))).multiply(h);
    // console.log("k2"+this.k2);
    // // this.k3 = this.k3.add(u(this.position.add(this.k2.divide(this.two)),this.velocity.add(this.h.divide(this.two)))).multiply(this.h);
    // console.log("k3"+this.k3);
    // this.k4 = this.k4.add(u(this.position.add(this.k3.clone()),this.velocity.add(this.h))).multiply(this.h);
    // console.log("k4"+this.k4);
    // this.bun = this.k1.clone().add(this.k2.clone().multiply(this.two)).add(this.k3.clone().multiply(this.two)).add(this.k4.clone()).divide(this.Six);
    // console.log("bundle="+this.bun)
    // this.positionI = this.position.add(this.bun);
    ///////////////////////////////////////////////////
    // ///////////////////////////////////////////////////
    // this.k1 = u(this.position.clone(),this.velocity.clone()).multiply(this.h);
    // console.log("k1"+this.k1);
    // this.k2 = u(this.position.clone().add(this.k1.clone().divide(this.two)),this.velocity.clone().add(this.h.clone().divide(this.two))).multiply(this.h);
    // this.k3 = u(this.position.clone().add(this.k2.clone().divide(this.two)),this.velocity.clone().add(this.h.clone().divide(this.two))).multiply(this.h);
    // this.k4 = u(this.position.clone().add(this.k3.clone()),this.velocity.clone().add(this.h)).multiply(this.h);

    // this.bun = this.k1.clone().add(this.k2.clone().divide(two)).add(this.k3.clone().divide(two)).add(this.k4.clone()).divide(this.Six);
    // console.log("test"+bun);
    // this.positionI = this.position.add(this.bun);
    // ////////////////////////////////////////////////////////
    // console.log("p"+this.positionI);
    // // this.velocity.add(this.h);
    // console.log(this.positionI);
    //console.log(this.k1);
    // // this.positionI = this.position.add()
    // var test = new Victor();
    // var u = new Victor(1,3);

    // test = test.add(u).add(u).multiply(h);
    // console.log(test);

    //this.positionI = this.position + 1/6*(k1+(2*k2)+(2*k3)+k4);
    //this.position.y = this.position.y.add(this.velocity.y);
    // k1 = this.position.add(this.velocity).multiply(0.1);
    // k2 = this.position.add(this.velocity.add(0.1/2)).multiply(k1/2).multiply(0.1);
    // k3 = this.position.add(this.velocity.add(0.1/2)).multiply(k2/2).multiply(0.1);
    // k4 = this.position.add(this.velocity.add(0.1)).multiply(k3/2).multiply(0.1);
    // this.position = this.position + 1/6*(k1+(2*k2)+(2*k3)+k4);
   
    // function rungeKutta(){
    // }
    // Loop through behaviors to apply forces

    this.flock();


    // Collision detection if enabled
    //console.log(this.position)
    if ( collisions ) { this.detectCollision(); }

    // Check edges for walls or overruns
    this.edgeCheck();
    //this.kaabaCheck()

  }


  edgeCheck() {
    if (walls) {
      this.wallBounce();
      //this.kaabaBounce();
    } else {
      this.borderWrap();
    }
  }


  borderWrap() {
    if (this.position.x < 0) {
      this.position.x = document.body.clientWidth;
    } else if ( this.position.x > document.body.clientWidth ) {
      this.position.x = 0;
    }
    if (this.position.y < 0) {
      this.position.y = document.body.clientHeight;
    } else if ( this.position.y > document.body.clientHeight ) {
      this.position.y = 0;
    }
  }




  wallBounce() {
    
    if (this.position.x <= this.radius) {
      this.position.x = this.radius;
    } else if ( this.position.x >= document.body.clientWidth - this.radius) {
      this.position.x = document.body.clientWidth - this.radius;
    }
    if (this.position.y <= this.radius) {
      this.position.y = this.radius;
    } else if ( this.position.y >= document.body.clientHeight - this.radius ) {
      this.position.y = document.body.clientHeight - this.radius;
    }
    if ( this.distanceFromHorWall() <= this.radius  ) {
      this.velocity.invertY();
    }
    if ( this.distanceFromVertWall() <= this.radius  ) {
      this.velocity.invertX();
    }
 
  }

 
  distanceFromVertWall() {
    if (this.velocity.x > 0) {
      return document.body.clientWidth - ( this.position.x );
    } else {
      return this.position.x;
    }

  }


  distanceFromHorWall() {
    if (this.velocity.y > 0) {
      return document.body.clientHeight - ( this.position.y );
    } else {
      return this.position.y;
    }
  }

  ///tambahan ikhsan 
  distanceFromHorKaaba(){
    if (this.velocity.y > 0){
      return wallskaaba.y - (this.position.y);
    } else {
      return this.position.y
    }
  }
  distanceFromVertKaaba(){
    if (this.velocity.x > 0) {
      return wallsKaaba.x - (this.position.x);
    } else {
      return this.position.x;
    }
  }

  wallKaabaBounce(){
    if (this.position.x <= this.radius) {
      this.position.x = this.radius;
    } else if ( this.position.x >= document.body.clientWidth - this.radius) {
      this.position.x = document.body.clientWidth - this.radius;
    }
    if (this.position.y <= this.radius) {
      this.position.y = this.radius;
    } else if ( this.position.y >= document.body.clientHeight - this.radius ) {
      this.position.y = document.body.clientHeight - this.radius;
    }
    if ( this.distanceFromHorWall() <= this.radius  ) {
      this.velocity.invertY();
    }
    if ( this.distanceFromVertWall() <= this.radius  ) {
      this.velocity.invertX();
    }

 
  }








  draw(){
    //c.beginPath();
    //transform the position 
    var rr = transform({x:this.positionI.x, y:this.positionI.y}); // tambahan ikhsan transformasi
    var theta = -1*Math.atan2(this.velocity.y,this.velocity.x); + Math.PI /2;
    var vr = transform({x:this.velocity.x, y:this.velocity.y}); // tambahan ikhsan transformasi
    var t,deltat;

    let r = this.radius;
    let sudut1=Math.PI*(0);
    let sudut2=Math.PI*((2/3)-(1/3));
    //let theta =-1*Math.atan2(this.velocity.x,this.velocity.y) + Math.PI /2;
    c.save();
    c.beginPath();


    c.arc(rr.x, rr.y, this.radius, 0, Math.PI * 2);
    c.fillStyle = this.color;
    c.fill();
    c.closePath();
    c.restore();

 
    draw(canvas,rr.x,rr.y,vr.x,vr.y,1,sudut1,sudut2,this.color);
    t=+deltat

 
  }

  startLine(){
    c.strokeStyle = "#ff0000";
    c.beginPath();
    c.moveTo(center.x-50,center.y-50);
    c.lineTo(center.x,center.y);
    c.moveTo(center.x,center.y);
    c.lineTo(1020,820);
    c.moveTo(center.x-10,center.y);
    c.lineTo(988,820);
    c.moveTo(center.x,center.y-10);
    c.lineTo(1050,820);
    //c.fillStyle = "#ff0000";
    c.fill();
    c.stroke();
  }

  drawArrow(){
    c.strokeStyle = "#ff0000";
    c.beginPath();
    c.moveTo(this.position.x,this.position.y);
    c.lineTo(center.x,center.y);
    c.stroke();
  }
  
  update() { 
    //this.transform();// tambahan ikhsan
    var sudut1=Math.PI*(0);
    var sudut2=Math.PI*((2/3)-(1/3));

    this.draw();
    ///draw all boundary except kaaba
    //this.startLine();
    
    //this.circularPath();
    ///
    this.nextPosition();
    c.beginPath();

    c.closePath();

    //this.draw(); //awalnya disini
  }




  detectCollision(){

    for (var i = 0; i < boids.length; i++) {
      if ( this === boids[i] ) { continue; }
      if ( getDistance( this.position.x, this.position.y, boids[i].position.x, boids[i].position.y) - ( this.radius + boids[i].radius ) < 0 ) {
        this.resolveCollision( this, boids[i]);
      }
    }
  }


  rotate(velocity, angle) {
    return {
        x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),
        y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)
    };
  }


   resolveCollision(boid, otherBoid) {

      var xVelocityDiff = boid.velocity.x - otherBoid.velocity.x;
      var yVelocityDiff = boid.velocity.y - otherBoid.velocity.y;

      var xDist = otherBoid.position.x - boid.position.x;
      var yDist = otherBoid.position.y - boid.position.y;

      // Prevent accidental overlap of boids
      if ( xVelocityDiff * xDist + yVelocityDiff * yDist >= 0 ) {

        // Grab angle between the two colliding boids
        var angle = -Math.atan2(otherBoid.position.y - boid.position.y, otherBoid.position.x - boid.position.x);

        // Store mass in var for better readability in collision equation
        var m1 = boid.mass;
        var m2 = otherBoid.mass;

        // Velocity before equation
        var u1 = this.rotate(boid.velocity, angle);
        var u2 = this.rotate(otherBoid.velocity, angle);

        // Velocity after 1d collision equation
        var v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };
        var v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y };

        // Final velocity after rotating axis back to original position
        var vFinal1 = this.rotate(v1, -angle);
        var vFinal2 = this.rotate(v2, -angle);

        // Swap boid velocities for realistic bounce effect
        boid.velocity.x = vFinal1.x;
        boid.velocity.y = vFinal1.y;
        boid.velocity.limitMagnitude(boid.maxSpeed);

        otherBoid.velocity.x = vFinal2.x;
        otherBoid.velocity.y = vFinal2.y;
        otherBoid.velocity.limitMagnitude(otherBoid.maxSpeed);
      }

    }

}
\end{lstlisting}

\section{Kode Program script.js}
\begin{lstlisting}

/*---- Global Setup ----*/

// Set up canvas
const canvas = document.getElementById('boids');
const c = canvas.getContext('2d');

//Get Firefox
var browser=navigator.userAgent.toLowerCase();
if(browser.indexOf('firefox') > -1) {
  var firefox = true;
}

// Detect Mobile
var mobile = ( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) ? true : false;

// Set Size
var size = {
  width: window.innerWidth || document.body.clientWidth,
  height: window.innerHeight || document.body.clientHeight
}
console.log("ini bodi client"+document.body.clientWidth+"dan"+document.body.clientHeight);
canvas.width = size.width;
canvas.height = size.height;
console.log("besar canvas");
console.log(size.width);
console.log(size.height);

var center = new Victor( size.width / 2 ,size.height / 2 );
console.log("pusat"+center.x);


// Initialize Mouse
var mouse = {
  position: new Victor( innerWidth / 2, innerHeight / 2 )
};

/*---- end Global Setup ----*/

/*---- Helper Functions ----*/

/**
 * Returns a random int between a min and a max
 *
 * @param  int | min | A minimum number
 * @param  int | max | A maximum number
 * @return int | The random number in the given range
 */
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Returns the distance between two coordinates
 *
 * @param  int | x1 | Point 1's x coordinate
 * @param  int | y1 | Point 1's y coordinate
 * @param  int | x2 | Point 2's x coordinate
 * @param  int | y2 | Point 2's y coordinate
 * @return int | The distance between points 1 and 2
 */
function getDistance(x1, y1, x2, y2) {
  var xDist = x2 - x1;
  var yDist = y2 - y1;
  return Math.sqrt( Math.pow(xDist, 2) + Math.pow(yDist, 2) );
}

/**
 * Returns a random color from the colors array
 *
 * @param  array | colors | An array of color values
 * @return string | The random color value
 */
function randomColor(colors) {
  return colors[ Math.floor( Math.random() * colors.length) ];
}

/**
 * Get coefficients based on normal distribution
 *
 * @param  int | mean | The mean value of the data set
 * @param  int | stdev | The standard deviation for the data set
 * @return int | A number from the data set
 */
function gaussian(mean, stdev) {
    var y2;
    var use_last = false;
    return function() {
        var y1;
        if(use_last) {
           y1 = y2;
           use_last = false;
        }
        else {
            var x1, x2, w;
            do {
                 x1 = 2.0 * Math.random() - 1.0;
                 x2 = 2.0 * Math.random() - 1.0;
                 w  = x1 * x1 + x2 * x2;
            } while( w >= 1.0);
            w = Math.sqrt((-2.0 * Math.log(w))/w);
            y1 = x1 * w;
            y2 = x2 * w;
            use_last = true;
       }

       var retval = mean + stdev * y1;
       if(retval > 0)
           return retval;
       return -retval;
       console.log("tes retval"+retval);
   }
}

var getCoefficient = gaussian(50, 9); //(50,9)
var getQuicknessCoefficient = gaussian(75,7.5); //(75,7.5)

/**
 * Add Limit Magnitude function to Victor objects
 *
 * @param  int | max | The limit magnitude for the vector
 */
Victor.prototype.limitMagnitude = function (max) {

  if (this.length() > max) {
    this.normalize();
    this.multiply({x:max,y:max});
  }

};
/**
 * Convert angle to radian
 *
 * @param  int | sudut | angle that convert
 */

function toRadian (sudut) {
  return sudut * (Math.PI / 180);
}

/*--- end Helper Functions ----*/

/*---- Loop and Initializing ----*/

// Checkbox Options
var walls = true;
var mouseSeek = false;
var collisions = false;

/*---- How much Boids ----*///120
var allBoids = 100;//1000;
var numAllBoids = allBoids;

var minBoids = 60;//1000;
var numBoids = minBoids;

var agroBoids = 20;//1000;//20
var numAgBoids = agroBoids;

var blackBoids = 20;//20
var numBlBoids =blackBoids;

// Set possible radii  based on screen size
var radius;
if ( size.width / 288 > 5 ) {
  radius = 5;
} else if ( size.width / 288 < 3) {
  radius = 3;
} else {
  radius = size.width / 288;
}
var radiusCoefficients = [.5,.6,.7,.8,.9,1];

// Boid Attributes
var colors = [
  '#4286f4',
  '#7df442',
  '#41f4a0',
  '#f9f9f9',
  '#a341f4',
  '#f48341',
  '#f4e841',
  '#42ebf4'
];

var colorsBlack = [
  '#000000'
];

var colorsRed = [
  '#FF0000'
];

var colorsYellow = [
  ' #FFFF00'
];

var diversity = 8;

var quickness = 1;
var agroQuickness = 1.25;
var blackQuickness = 0.5;

var introversion = .5;
var racism = 1; // 0 awalnya coba 5
var speedIndex;
if ( size.width / 160 < 5 ) {
  speedIndex = 1.25;//5 DEFAULT x
} else if ( size.width / 180 > 8 ) {
  speedIndex = 2.25;//9
} else {
  speedIndex = size.width / 180;
}
var maxForceAggro = 0.4;

// Create Boids Array
var boids = [];

// Other 
var trigger = true;
/**
 * Create Boids Array
 *
 */
function createBoids() {

  // Instantiate all Boids
  for ( i = 0; i < numBoids; i++ ) {

    // Generate introversion coefficient
    var introversionCoefficient = getCoefficient() / 100;
    var quicknessCoefficient = getQuicknessCoefficient() / 100;
    var racismCoefficient = getCoefficient() / 100;
    var radiusCoefficient = Math.floor(Math.random() * radiusCoefficients.length);

    // Generate random coords MUST FROM 50 TO SIZE CANVAS OR WALL MASJIDIL
    // if ( distanceFromCenter > 300 && distanceFromCenter < 1500){
    //   var x = Math.ceil(Math.random()* ( getRandomInt(center.x+50,size.width) - ( radius * 2 ) ) ) + ( radius );//size.width
    //   var y = Math.ceil(Math.random()* ( getRandomInt(center.y+50,size.height) - ( radius * 2 ) ) ) + ( radius );//size.height
    // }
    var x = Math.ceil(Math.random()* ( getRandomInt(center.x+50,size.width) - ( radius * 2 ) ) ) + ( radius );//size.width
    var y = Math.ceil(Math.random()* ( getRandomInt(center.y+50,size.height) - ( radius * 2 ) ) ) + ( radius );//size.height
    // For subsequent boids, check for collisions and generate new coords if exist
    if ( i !== 0 ) {
      for (var j = 0; j < boids.length; j++ ) {
        if ( getDistance(x, y, boids[j].x, boids[j].y) - ( radius + boids[j].radius ) < 0 ) {
          x = Math.ceil(Math.random()* ( getRandomInt(center.x+50,size.width) - ( radius * 2 ) ) ) + ( radius );//size.width
          y = Math.ceil(Math.random()* ( getRandomInt(center.y+50,size.height) - ( radius * 2 ) ) ) + ( radius );//size.height
          j = -1;
        }
      }
    }

    // Add new Boid to array
    boids.push( new Boid( {
      id: i,
      x: x,
      y: y,
      speedIndex: speedIndex,
      radius: radius,
      radiusCoefficient: radiusCoefficient,
      quickness: quickness,
      quicknessCoefficient: quicknessCoefficient,
      color: randomColor(colors),
      racism: racism,
      racismCoefficient: racismCoefficient,
      introversion: introversion,
      introversionCoefficient: introversionCoefficient
      //maxForce: maxForce
    } ) );


    // Add new black Boid to array 
    // boids.push( new Boid( {
    //   id: i,
    //   x: x,
    //   y: y,
    //   speedIndex: speedIndex,
    //   radius: radius,
    //   radiusCoefficient: radiusCoefficient,
    //   quickness: quickness,
    //   quicknessCoefficient: quicknessCoefficient,
    //   color: colorsBlack,
    //   racism: racism,
    //   racismCoefficient: ,
    //   introversion: introversion,
    //   introversionCoefficient: introversionCoefficient
    // } ) );
  }

}

function agressiveBoids() {

  // Instantiate all Boids
  for ( i = 0; i < numAgBoids; i++ ) {

    // Generate introversion coefficient
    var introversionCoefficient = getCoefficient() / 100;
    var quicknessCoefficient = getQuicknessCoefficient() / 100;
    var racismCoefficient = getCoefficient() / 100;
    var radiusCoefficient = Math.floor(Math.random() * radiusCoefficients.length);

    // Generate random coords MUST FROM 50 TO SIZE CANVAS OR WALL MASJIDIL
    // if ( distanceFromCenter > 300 && distanceFromCenter < 1500){
    //   var x = Math.ceil(Math.random()* ( getRandomInt(center.x+50,size.width) - ( radius * 2 ) ) ) + ( radius );//size.width
    //   var y = Math.ceil(Math.random()* ( getRandomInt(center.y+50,size.height) - ( radius * 2 ) ) ) + ( radius );//size.height
    // }
    var x = Math.ceil(Math.random()* ( getRandomInt(center.x+50,size.width) - ( radius * 2 ) ) ) + ( radius );//size.width
    var y = Math.ceil(Math.random()* ( getRandomInt(center.y+50,size.height) - ( radius * 2 ) ) ) + ( radius );//size.height
    // For subsequent boids, check for collisions and generate new coords if exist
    if ( i !== 0 ) {
      for (var j = 0; j < boids.length; j++ ) {
        if ( getDistance(x, y, boids[j].x, boids[j].y) - ( radius + boids[j].radius ) < 0 ) {
          x = Math.ceil(Math.random()* ( getRandomInt(center.x+50,size.width) - ( radius * 2 ) ) ) + ( radius );//size.width
          y = Math.ceil(Math.random()* ( getRandomInt(center.y+50,size.height) - ( radius * 2 ) ) ) + ( radius );//size.height
          j = -1;
        }
      }
    }

    // Add new Boid to array
    boids.push( new Boid( {
      id: i,
      x: x,
      y: y,
      speedIndex: speedIndex,
      radius: radius,
      radiusCoefficient: radiusCoefficient,
      quickness: agroQuickness,
      quicknessCoefficient: quicknessCoefficient,
      color: colorsRed,
      racism: racism,
      racismCoefficient: racismCoefficient,
      introversion: introversion,
      introversionCoefficient: introversionCoefficient,
      //maxForce: maxForceAggro
    } ) );

  }

}

function slowBoids() {

  // Instantiate all Boids
  for ( i = 0; i < numBlBoids; i++ ) {

    // Generate introversion coefficient
    var introversionCoefficient = getCoefficient() / 100;
    var quicknessCoefficient = getQuicknessCoefficient() / 100;
    var racismCoefficient = getCoefficient() / 100;
    var radiusCoefficient = Math.floor(Math.random() * radiusCoefficients.length);

    // Generate random coords MUST FROM 50 TO SIZE CANVAS OR WALL MASJIDIL
    // if ( distanceFromCenter > 300 && distanceFromCenter < 1500){
    //   var x = Math.ceil(Math.random()* ( getRandomInt(center.x+50,size.width) - ( radius * 2 ) ) ) + ( radius );//size.width
    //   var y = Math.ceil(Math.random()* ( getRandomInt(center.y+50,size.height) - ( radius * 2 ) ) ) + ( radius );//size.height
    // }
    var x = Math.ceil(Math.random()* ( getRandomInt(center.x+50,size.width) - ( radius * 2 ) ) ) + ( radius );//size.width
    var y = Math.ceil(Math.random()* ( getRandomInt(center.y+50,size.height) - ( radius * 2 ) ) ) + ( radius );//size.height
    // For subsequent boids, check for collisions and generate new coords if exist
    if ( i !== 0 ) {
      for (var j = 0; j < boids.length; j++ ) {
        if ( getDistance(x, y, boids[j].x, boids[j].y) - ( radius + boids[j].radius ) < 0 ) {
          x = Math.ceil(Math.random()* ( getRandomInt(center.x+50,size.width) - ( radius * 2 ) ) ) + ( radius );//size.width
          y = Math.ceil(Math.random()* ( getRandomInt(center.y+50,size.height) - ( radius * 2 ) ) ) + ( radius );//size.height
          j = -1;
        }
      }
    }

    // Add new Boid to array
    boids.push( new Boid( {
      id: i,
      x: x,
      y: y,
      speedIndex: speedIndex,
      radius: radius,
      radiusCoefficient: radiusCoefficient,
      quickness: blackQuickness,
      quicknessCoefficient: quicknessCoefficient,
      color: colorsBlack,
      racism: racism,
      racismCoefficient: racismCoefficient,
      introversion: introversion,
      introversionCoefficient: introversionCoefficient
      //maxForce: maxForce
    } ) );

  }

}



/**
 * function draw walls kaaba
 *
 */

/////////////////////////////
 //bikin sekat area luar
 //outer walls
  //1 banding 3 scalar
  function Vect2() {
    this.x = 0;
    this.y = 0;
  }

  var sx = center.x;
  var sy = center.y;
  var s11 = 219; // 73
  var s12 = 216; // 72
  var s21 = 219; // 73
  var s22 = 225; // 75
  var s31 = 219; // 73
  var s32 = 216; // 72
  var s41 = 225; // 75
  var s42 = 219; // 73
  var wA = new Vect3(-s11,s12,0);
  var wB = new Vect3(s21, s22,0);
  var wC = new Vect3(s31,-s32,0);
  var wD = new Vect3(-s41, -s42,0);
  //console.log(rA);

  // Define wall
  //var surf = new Sides2(); //barrier
  var sides = [];
  surf = new Sides2(wA,wB);
  sides.push(surf);
  surf = new Sides2(wB,wC);
  sides.push(surf);
  surf = new Sides2(wC,wD);
  sides.push(surf);
  surf = new Sides2(wD,wA);
  sides.push(surf);


   //kaaba walls
  var s = 50 
  var sx = center.x;
  var sy = center.y;
  var rA = new Vect3(sx,sy,0);
  var rB = new Vect3(sx-s,sy,0);
  var rC = new Vect3(sx-s,sy-s,0);
  var rD = new Vect3(sx,sy-s ,0);


  // var s = 100
  // var s2 = 150 
  // var sx = center.x;
  // var sy = center.y;
  // var rA = new Vect3(sx-s,sy-s2,0);
  // var rB = new Vect3(sx+s,sy+s2 ,0);
  // var rC = new Vect3(sx+s,sy-s2,0);
  // var rD = new Vect3(sx-s,sy+s2 ,0);




  // Define kaaba //change from sides to walls
  var surf = new Sides2();
  var wallsKaaba = [];
  surf = new Sides2(rA,rB);
  wallsKaaba.push(surf);
  surf = new Sides2(rB,rC);
  wallsKaaba.push(surf);
  surf = new Sides2(rC,rD);
  wallsKaaba.push(surf);
  surf = new Sides2(rD,rA);
  wallsKaaba.push(surf);
  surf = new Sides2(rA,rC); 
  var vecKaaba = Victor.fromArray(wallsKaaba);
  console.log("tes"+vecKaaba);

  //make center var surf


  console.log("x="+surf.center().x);
  console.log("y="+surf.center().y);

  console.log("koordinat tengah"+surf.center());
  console.log(surf.strval());

  console.log("arrayof kaaba"+wallsKaaba);
  console.log("tes"+wallsKaaba[0].p[0].x);
  console.log();
  // console.log("tes"+walls[0].p[0].x.length);
  // console.log(surf.p[0].x);


 
  //console.log(sides); 
function drawWalls(id,surfs,color){
  var cx = document.getElementById("boids").getContext("2d");
    cx.strokeStyle = color;
    var N = surfs.length;
    //console.log(N);
    for(var i = 0; i < N; i++) {
      var M = surfs[i].p.length;
      //console.log(M);
      cx.beginPath();
      for(var j = 0; j < M; j++) {
        var s = surfs[i];
        var rr = transform({x: s.p[j].x, y: s.p[j].y});
        if(j == 0) {
          cx.moveTo(rr.x, rr.y);
        } else {
          cx.lineTo(rr.x, rr.y);
        }
      }
      cx.stroke();
    }
    c.strokeStyle = "#ff0000";
    c.beginPath();
    // c.moveTo(center.x-50,center.y-50);
    // c.lineTo(center.x,center.y);
    c.moveTo(center.x,center.y);
    c.lineTo(1020,820);
    c.moveTo(center.x-10,center.y);
    c.lineTo(988,820);
    c.moveTo(center.x,center.y-10);
    c.lineTo(1050,820);
    //c.fillStyle = "#ff0000";
    c.fill();
    c.stroke();
  
}
// Define world coordinate
  var xmin = 0;//-1*(size.width/2);//0//-1*(size.width/2);//360
  var ymin = 0;//-1*(size.width/2);//0//-1*(size.height/2);//
  var xmax = size.width//size.width//size.width/2;//
  var ymax = size.height//size.height//size.height/2;//

  // Define canvas size
  // var canvasWidth = 720;
  // var canvasHeight = 720;

  // Define canvas coordinate
  var XMIN = 0;
  var YMIN = 0;//
  var XMAX = size.width;//
  var YMAX = size.height;

function transform(r) {
    var X = (r.x - xmin) / (xmax - xmin) * (XMAX - XMIN);
    X += XMIN;
    var Y = (r.y - ymin) / (ymax - ymin) * (YMAX - YMIN);
    Y += YMIN;
    return {x: X, y: Y};
  }

//////////////////////////////////////////////////////

/**
 * Setup and call animation function
 *
 */
  var t=0,dt=1;
  //var arr=[]; //y
  //var arr1=[];//x
     
  var arrt=[];
  var arr =[];

  var arry=[];
  var arry1=[];
  var arry2=[];
  var arry3=[];
  var arry4=[];
  var arry5=[];
  
  var Vb1,Vb2,Vb3,Vb4,Vb5;

  var aB1,aB2;

  var verR1;

function animate() {
  requestAnimationFrame(animate);

  // Calc elapsed time since last loop
  now = Date.now();
  elapsed = now - then;
  //console.log("elapsed"+elapsed);

  // FPS Reporting
  fpsReport++;
  if (fpsReport > 60) {
    fpsNum.innerHTML = Math.floor(1000/elapsed);
    fpsReport = 0;
  }

  // If enough time has elapsed, draw the next frame
  if (elapsed > fpsInterval) {
      // Get ready for next frame by setting then=now, but also adjust for your
      // specified fpsInterval not being a multiple of RAF's interval (16.7ms)
      then = now - (elapsed % fpsInterval);
      // Drawing Code
      t+=dt
    function simulate() {
      c.clearRect(0, 0, canvas.width, canvas.height);
      var arr=[]; //y
      var arr1=[];//x
      var arr2=[];
      var arr3=[];
      var verR;
      // Update all boids
    function test(){
      if(trigger== true){
        for (var i = 0; i < boids.length; i++ ) {
        //arr.push(boids[i].velocity.length());
        boids[i].update();
        arr.push(boids[i].velocity.length());
        arr2.push(boids[i].position.x);
        arr3.push(boids[i].position.y);
        drawWalls("walls", wallsKaaba, "#f00");// 
        //drawWalls("walls", sides, "#f00");//
          }
    }
      console.log(arr2);
      console.log(arr3);
      //console.log(n[1].x);



      //arr1.push(t);
      // t+=dt
      console.log(arr1);
      }
      console.log(arr1);
      test();
      console.log(arr[1]);
      Vb1 = arr[99];
      Vb2 = arr[98];
      Vb3 = arr[97];
      Vb4 = arr[96];
      Vb5 = arr[95];

      aB1 =arr2;
      aB2 =arr3;
      console.log(aB1);



      console.log(Vb1);
      //arr1.push(t);
      //console.log(arr);
      // console.log(
      // arr.reduce((a, b) => a + b, 0)
      // )
      verR = arr.reduce((a, b) => a + b, 0);
      //verR1 = verR/boids[i].length();
      verR1 = verR/numAllBoids;
      const verR2 = verR1
      //console.log(verR1);  
      //console.log(arr1);
      //console.log(verR2);
      // for(let i = 0; i < 2; i++  ){
        
      //   arrt.push(verR2);
      // }
      
      
      // //arrt.push(verR2);
      // console.log(arrt);
      //
      const N = 10, t_0 = 0, t_1 = 1, y_0 = 0
      const h = (t_1 - t_0) / N  //time step size

      //var ts = Array.from(Array(N+1), (_, k) => k * h + t_0)
      //var ys = Array(N+1).fill(0)  //empty array for the results
      var ts = [];
      //var ys = Array.from(verR1+1).fill(0)
      var ys =[];
      ys[0] = y_0  //initial conditions

      function f(v,ts){
        var u,v,ts;
        u=v*t;
        return u;
      }
      var resolution = 100;
      var y=[],s=[],yts;
      for (let i = 0; i < resolution; i++) {
         ts[i]=i;
         ys[i]=verR1;
         const k1 = f(ts[i], ys[i])

         const s1 = ys[i] + k1 * h/2
         const k2 = f(ts[i] + h/2, s1)

         const s2 = ys[i] + k2 * h/2
         const k3 = f(ts[i] + h/2, s2) 

         const s3 = ys[i] + k3 * h
         const k4 = f(ts[i] + h, s3) // f(t + h, y_n + k3*h)
         ys[i + 1] = ys[i] + (k1/6 + k2/3 + k3/3 + k4/6) * h
         //yts.copy(ys[i+1]);
         //y.push(yts.clone());
         y.push(ys[i+1])
         //console.log(ys[i+1]);
         s.push(ts[i]);
           
      }
      console.log(y);
      console.log(s);
      //
      //console.log(arrt);
      // var tes= [1,2,3,4,5];
      // var testwo= [6,7,4,3,1];
     
    //openGraph(s,y);
    }
    simulate();



    function openGraph(tes,testwo1,testwo2,testwo3,testwo4,testwo5){
      var tes;
      var testwo;
      var testwo1;
      var testwo2;
      var testwo3;
      var testwo4;
      var testwo5;
      var graph1={
      x: tes,
      y: testwo1,
      mode: 'lines+markers',
      type: 'scatter',
      name: 'dots1'
      };
      var graph2={
      x: tes,
      y: testwo2,
      mode: 'lines+markers',
      type: 'scatter',
      name: 'dots2'
      };
      var graph3={
      x: tes,
      y: testwo3,
      mode: 'lines+markers',
      type: 'scatter',
      name: 'dots3'
      };
      var graph4={
      x: tes,
      y: testwo4,
      mode: 'lines+markers',
      type: 'scatter',
      name: 'dots4'
      };
      var graph5={
      x: tes,
      y: testwo5,
      mode: 'lines+markers',
      type: 'scatter',
      name: 'dots5'
      };
      var data1 =[graph1,graph2,graph3,graph4,graph5];
      var gambar1= {
      title: {
        text:'Grafik 1',
        font: {
        family: 'Courier New, monospace',
        size: 24
        },
        xref: 'paper',
        x: 0.05,
      },
      xaxis: {
       title: {
       text: 'T(waktu)',
       font: {
       family: 'Courier New, monospace',
       size: 18,
       color: '#7f7f7f'
       }
       },
      },
      yaxis: {
       title: {
       text: 'V(kecepatan)',
       font: {
       family: 'Courier New, monospace',
       size: 18,
       color: '#7f7f7f'
       }
       }
      }
      };
     ;
      // Opens a new window
      var myWindow = window.open("", "myWindow", "width=1080,height=720");   
      myWindow.document.createElement("div");
      const graph = document.createElement("div");
      graph.setAttribute('id', 'area3');
      myWindow.document.body.appendChild(graph);
      Plotly.newPlot(graph, data1, gambar1,"")
     }
    function openGraph1(tes,testwo){
      var tes;
      var testwo;
      
      var graph1={
      x: tes,
      y: testwo,
      mode: 'lines+markers',
      type: 'scatter',
      name: 'dots1'
      };
      
      var data1 =[graph1];
      var gambar1= {
      title: {
        text:'Grafik 1',
        font: {
        family: 'Courier New, monospace',
        size: 24
        },
        xref: 'paper',
        x: 0.05,
      },
      xaxis: {
       title: {
       text: 'T(waktu)',
       font: {
       family: 'Courier New, monospace',
       size: 18,
       color: '#7f7f7f'
       }
       },
      },
      yaxis: {
       title: {
       text: 'V(kecepatan)',
       font: {
       family: 'Courier New, monospace',
       size: 18,
       color: '#7f7f7f'
       }
       }
      }
      };
     ;
      // Opens a new window
      var myWindow = window.open("", "myWindow", "width=1080,height=720");   
      myWindow.document.createElement("div");
      const graph = document.createElement("div");
      graph.setAttribute('id', 'area3');
      myWindow.document.body.appendChild(graph);
      Plotly.newPlot(graph, data1, gambar1,"")
     }
  }
  // console.log(y);
  // console.log(s);
arrt.push(t);
//arry.push(verR1);
arry1.push(Vb1);
arry2.push(Vb2);
arry3.push(Vb3);
arry4.push(Vb4);
arry5.push(Vb5);
// console.log(arrt);
 // console.log(arry);
 // console.log(arry1);
 // console.log(arry2);
 // console.log(arry3);
//openGraph(arrt,arry1,arry2,arry3,arry4,arry5);
//openGraph1(aB1,aB2);

   
}
// arrt.push(t);
// arry.push(verR1);
// console.log(arrt);
// console.log(verR1);



function clear(){
  var ca = arguments[0];
  var ctx = ca.getContext("2d");
  ctx.beginPath();
  ctx.clearRect(0,0,size.width,size.height);
  ctx.closePath();
}


// Setup animation
var stop = false;
var frameCount = 0;
var fps, fpsInterval, startTime, now, then, elapsed;
var fpsNum = document.getElementById('fps-number');
var fpsReport = 58;
/**
 * Start Animation of Boids
 *
 */
function startAnimating() {
  if(fps == null) { var fps = 60; }
  fpsInterval = 1000 / fps;
  then = Date.now();
  startTime = then;
  animate();
}
/**
 * Stop Animation of Boids
 *
 */

 function stopAnimating() {
  if(fps != null) { var fps = null; }
  fpsInterval = 1000 / fps;
  then = Date.now();
  startTime = then;
  //animate();
}



/*---- end Loop and Initializing ----*/

/*---- Event Listeners ----*/

/**
 * Update mouse positions on mousemove
 *
 */
addEventListener('mousemove', function(event){
  mouse.position.x = event.clientX;
  mouse.position.y = event.clientY;
});

/**
 * Update boundary sizes on window resize
 *
 */
addEventListener('resize', function(){
  size.width = innerWidth;
  size.height = innerHeight;
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  center.x = size.width/ 2;
  center.y = size.height / 2;
  if ( innerWidth >= 1000 && ! mobile ) {
    document.getElementById('mobile-boids-controls').style.display = 'none';
  } else {
    document.getElementById('mobile-boids-controls').style.display = 'block';
  }
});

/*---- end Event Listeners ----*/

/*---- Inputs ----*/

var buttonStart = document.getElementById('Start');
buttonStart.onclick = function(){
//Initalize program
var id = event.target.id;
createBoids();
agressiveBoids();
slowBoids();
startAnimating(60);
}

// var buttonStart2 = document.getElementById('Start2');
// buttonStart.onclick = function(){
// //Initalize program
// var id = event.target.id;
// createBoids();
// startAnimating(60);
// }


var buttonStop = document.getElementById('Stop');
buttonStop.onclick = function(){
 c.clearRect(0, 0, canvas.width, canvas.height);
 stopAnimating(0);
}

// Hide Elements on Mobile
document.getElementById('collisions-mobile').style.display = 'none';
document.getElementById('mouse-seek-mobile').style.display = 'none';

// Mobile Closers
var mobileClosers = document.getElementsByClassName('boids-control-close');
for (var i = 0; i < mobileClosers.length; i++) {
  mobileClosers[i].onclick = function() {
    this.parentNode.classList.toggle('show');
    document.getElementById('mobile-boids-controls').style.display = 'block';
  }
}

// Walls
var wallsInput = document.getElementById('walls');
wallsInput.checked = true;
wallsInput.onclick = function() {
  if ( !this.checked ) {
    this.checked = false;
    wallsMobile.dataset.checked = false;
    wallsMobile.classList.toggle('boids-checkbox-on');
    walls = false;
  } else {
    this.checked = true;
    wallsMobile.dataset.checked = true;
    wallsMobile.classList.toggle('boids-checkbox-on');
    walls = true;
  }
}
var wallsMobile = document.getElementById('walls-mobile');
wallsMobile.dataset.checked = true;
wallsMobile.onclick = function() {
  if ( this.dataset.checked == 'false') {
    this.dataset.checked = true;
    wallsInput.checked = true;
    this.classList.toggle('boids-checkbox-on');
    walls = true;
  } else {
    this.dataset.checked = false;
    wallsInput.checked = false;
    this.classList.toggle('boids-checkbox-on');
    walls = false;
  }
}

// Collision Detection
var collisionDetectionInput = document.getElementById('collision-detection');
collisionDetectionInput.checked = false;
collisionDetectionInput.onclick = function() {
  if ( !this.checked ) {
    this.checked = false;
    collisionDetectionMobile.dataset.checked = false;
    collisionDetectionMobile.classList.toggle('boids-checkbox-on');
    collisions = false;
  } else {
    this.checked = true;
    collisionDetectionMobile.dataset.checked = true;
    collisionDetectionMobile.classList.toggle('boids-checkbox-on');
    collisions = true;
  }
}
var collisionDetectionMobile = document.getElementById('collisions-mobile');
collisionDetectionMobile.dataset.checked = false;
collisionDetectionMobile.onclick = function() {
  if ( this.dataset.checked == 'false') {
    this.dataset.checked = true;
    collisionDetectionInput.checked = true;
    this.classList.toggle('boids-checkbox-on');
    collisions = true;
  } else {
    this.dataset.checked = false;
    collisionDetectionInput.checked = false;
    this.classList.toggle('boids-checkbox-on');
    collisions = false;
  }
}

// Mouse Seek
var mouseSeekInput = document.getElementById('mouse-seek');
mouseSeekInput.checked = false;
mouseSeekInput.onclick = function() {
  if ( !this.checked ) {
    this.checked = false;
    mouseSeekMobile.dataset.checked = false;
    mouseSeekMobile.classList.toggle('boids-checkbox-on');
    mouseSeek = false;
  } else {
    this.checked = true;
    mouseSeekMobile.dataset.checked = true;
    mouseSeekMobile.classList.toggle('boids-checkbox-on');
    mouseSeek = true;
  }
}
var mouseSeekMobile = document.getElementById('mouse-seek-mobile');
mouseSeekMobile.dataset.checked = false;
mouseSeekMobile.onclick = function() {
  if ( this.dataset.checked == 'false') {
    this.dataset.checked = true;
    mouseSeekInput.checked = true;
    this.classList.toggle('boids-checkbox-on');
    mouseSeek = true;
  } else {
    this.dataset.checked = false;
    mouseSeekInput.checked = false;
    this.classList.toggle('boids-checkbox-on');
    mouseSeek = false;
  }
}

// Introversion
var introversionControlContainer = document.getElementById('introversion-control-container');
var introversionInput = document.getElementById('introversion');
introversionInput.onchange = function() {
  introversion = this.value / 10;
  updateIntroversion(introversion);
}
var introversionMobile = document.getElementById('introversion-mobile');
introversionMobile.onclick = function() {
  document.getElementById('mobile-boids-controls').style.display = 'none';
  introversionControlContainer.classList.toggle('show');
}
function updateIntroversion(value) {
  for (var i=0; i<boids.length; i++) {
    boids[i].introversion = value * boids[i].introversionCoefficient;
  }
}

// Speed
var speedControlContainer = document.getElementById('speed-control-container');
var speedInput = document.getElementById('speed');
speedInput.onchange = function() {
  quickness = this.value / 10 + .5;
  updateQuickness(quickness);
}
var speedMobile = document.getElementById('speed-mobile');
speedMobile.onclick = function() {
  document.getElementById('mobile-boids-controls').style.display = 'none';
  speedControlContainer.classList.toggle('show');
}
function updateQuickness(value) {
  for (var i=0; i<boids.length; i++) {
    boids[i].quickness = value * boids[i].quicknessCoefficient;
    boids[i].maxSpeed = speedIndex * boids[i].quickness;
  }
}

// //Red Speed
// var speedControlContainer = document.getElementById('Rspeed-control-container');
// var speedInput = document.getElementById('Rspeed');
// speedInput.onchange = function() {
//   quickness = this.value / 10 + .5;
//   updateQuickness(quickness);
// }
// var speedMobile = document.getElementById('Rspeed-mobile');
// speedMobile.onclick = function() {
//   document.getElementById('mobile-boids-controls').style.display = 'none';
//   speedControlContainer.classList.toggle('show');
// }
// function updateQuickness(value) {
//   for (var i=0; i<boids.length; i++) {
//     boids[i].quickness = value * boids[i].quicknessCoefficient;
//     boids[i].maxSpeed = speedIndex * boids[i].quickness;
//   }
// }

// //Black Speed
// var speedControlContainer = document.getElementById('speed-control-container');
// var speedInput = document.getElementById('speed');
// speedInput.onchange = function() {
//   quickness = this.value / 10 + .5;
//   updateQuickness(quickness);
// }
// var speedMobile = document.getElementById('speed-mobile');
// speedMobile.onclick = function() {
//   document.getElementById('mobile-boids-controls').style.display = 'none';
//   speedControlContainer.classList.toggle('show');
// }
// function updateQuickness(value) {
//   for (var i=0; i<boids.length; i++) {
//     boids[i].quickness = value * boids[i].quicknessCoefficient;
//     boids[i].maxSpeed = speedIndex * boids[i].quickness;
//   }
// }



// Racisms
var racismControlContainer = document.getElementById('racism-control-container');
var racismInput = document.getElementById('racism');
racismInput.onchange = function() {
  racism = this.value / 5;
  updateRacism(racism);
}
var racismMobile = document.getElementById('racism-mobile');
racismMobile.onclick = function() {
  document.getElementById('mobile-boids-controls').style.display = 'none';
  racismControlContainer.classList.toggle('show');
}
function updateRacism(value) {
  for (var i=0; i<boids.length; i++) {
    boids[i].racism = value * boids[i].racismCoefficient;
  }
}

// Diversity
var diversityControlContainer = document.getElementById('diversity-control-container');
var diversityInput = document.getElementById('diversity');
diversityInput.onchange = function() {
  diversity = this.value;
  updateDiversity(diversity);
}
var diversityMobile = document.getElementById('diversity-mobile');
diversityMobile.onclick = function() {
  document.getElementById('mobile-boids-controls').style.display = 'none';
  diversityControlContainer.classList.toggle('show');
}
function updateDiversity(value) {
  for (var i=0; i<boids.length; i++) {
    boids[i].color = colors[ i % value ];
  }
}

\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{lampiran/riwayat}
